<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CJCM Order Validation Healthcheck</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: Segoe UI, Arial, sans-serif; margin: 20px; font-size: 13px; color: #222; }
    .note { color: #555; margin: 6px 0; font-size: 13px; }
    .error { color: #d93025; }
    .success { color: #188038; font-weight: 600; }
    table { border-collapse: collapse; width: 100%; margin-top: 10px; border: 1px solid #777; background: #fff; }
    th, td { border: 1px solid #777; padding: 6px 8px; font-size: 13px; background: #fff; }
    th { background: #f4f4f4; text-align: left; font-weight: 700; }
    td.num { text-align: center; }
    /* Limit WORKOBJECTSTATUS column width (first column) */
    table th:first-child, table td:first-child { max-width: 260px; width: 260px; white-space: normal; word-break: break-word; }
    .actions { margin: 10px 0; display: flex; gap: 12px; align-items: center; }
    .ranges { margin: 10px 0; display: flex; flex-wrap: wrap; gap: 8px; }
    .ranges button { padding: 6px 10px; font-size: 13px; }
    .spinner { display: inline-block; width: 14px; height: 14px; border: 2px solid #999; border-top-color: transparent; border-radius: 50%; animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div id="status" class="note">Select a date range to run.</div>
  <div class="ranges">
    <button data-range="15m" type="button">Last 15 minutes</button>
    <button data-range="1h" type="button">Last 1 hour</button>
    <button data-range="4h" type="button">Last 4 hours</button>
    <button data-range="8h" type="button">Last 8 hours</button>
    <button data-range="16h" type="button">Last 16 hours</button>
    <button data-range="1d" type="button">Last 1 Day</button>
    <button data-range="2d" type="button">Last 2 Days</button>
    <button data-range="3d" type="button">Last 3 Days</button>
  </div>
  <a id="previewLink" href="#" target="_blank" style="display:none;">Open email preview</a>
  <div id="rangeInfo" class="note"></div>
  <div id="results"></div>

  <script>
    const ORACLE_ENDPOINT = 'http://127.0.0.1:8765/oracle/query';
    const MAIL_ENDPOINT = 'http://127.0.0.1:8765/mail/send';
    // Active window (defaults to last 1 day)
    let activeWindow = { type: 'relative', value: '1d' };
    function toDate(s){ const d = new Date(s + 'T00:00:00'); return d; }
    function addDays(d, n){ const x = new Date(d); x.setDate(x.getDate() + n); return x; }
    function addMinutes(d, n){ const x = new Date(d); x.setMinutes(x.getMinutes() + n); return x; }
    function fmtLabel(d){
      const mons = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const mm = mons[d.getMonth()];
      const dd = String(d.getDate()).padStart(2,'0');
      const yy = String(d.getFullYear()).slice(-2);
      return `${dd}-${mm}-${yy}`;
    }
    function computeWindow(){
      const now = new Date();
      let start = addMinutes(now, -24*60), end = now; // default last 1 day
      if (activeWindow.type === 'relative'){
        const v = activeWindow.value;
        if (v.endsWith('m')){ const mins = parseInt(v); start = addMinutes(now, -mins); }
        else if (v.endsWith('h')){ const hrs = parseInt(v); start = addMinutes(now, -hrs*60); }
        else if (v.endsWith('d')){ const days = parseInt(v); start = addDays(now, -days); }
      }
      // Labels: unique set of truncated dates between start and end inclusive
      const labels = [];
      let cur = new Date(start.getFullYear(), start.getMonth(), start.getDate());
      const endDay = new Date(end.getFullYear(), end.getMonth(), end.getDate());
      while (cur <= endDay){ labels.push(new Date(cur)); cur = addDays(cur, 1); }
      return { start, end, labels };
    }

    // HTML escape utility used in table rendering
    function escapeHtml(s){
      return String(s ?? '').replace(/[&<>"']/g, c => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      })[c] || c);
    }

    // Build pivot SQL for a given base table over the selected window
    function makeSql(table){
      const { start, end, labels } = computeWindow();
      const s_ts = `${start.getFullYear()}-${String(start.getMonth()+1).padStart(2,'0')}-${String(start.getDate()).padStart(2,'0')}T${String(start.getHours()).padStart(2,'0')}:${String(start.getMinutes()).padStart(2,'0')}`;
      const e_ts = `${end.getFullYear()}-${String(end.getMonth()+1).padStart(2,'0')}-${String(end.getDate()).padStart(2,'0')}T${String(end.getHours()).padStart(2,'0')}:${String(end.getMinutes()).padStart(2,'0')}`;
      const pivots = labels.map(d => {
        const y = d.getFullYear();
        const m = String(d.getMonth()+1).padStart(2,'0');
        const day = String(d.getDate()).padStart(2,'0');
        const lbl = fmtLabel(d);
        return `TO_DATE('${y}-${m}-${day}', 'YYYY-MM-DD') AS "${lbl}"`;
      }).join(',\n        ');
      return `SELECT * FROM (\n    SELECT \n        WORKOBJECTSTATUS,\n        TRUNC(PXCREATEDATETIME) as CREATED_DATE,\n        COUNT(*) OVER (PARTITION BY WORKOBJECTSTATUS) as "Total"\n    FROM ${table}\n    WHERE PXCREATEDATETIME BETWEEN TO_TIMESTAMP('${s_ts}', 'YYYY-MM-DD"T"HH24:MI') \n                                 AND TO_TIMESTAMP('${e_ts}', 'YYYY-MM-DD"T"HH24:MI')\n)\nPIVOT (\n    COUNT(CREATED_DATE) \n    FOR CREATED_DATE IN (\n        ${pivots}\n    )\n)\nORDER BY "Total" DESC`;
    }

    // Subject line range text (e.g., Jan 10 2026 to Jan 12 2026)
    function fmtSubjectRange(){
      const { start, end } = computeWindow();
      const mons = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const sTxt = `${mons[start.getMonth()]} ${start.getDate()} ${start.getFullYear()}`;
      const eTxt = `${mons[end.getMonth()]} ${end.getDate()} ${end.getFullYear()}`;
      return `CJCM Order Validation Healthcheck Report - ${sTxt} to ${eTxt}`;
    }

    // Browser/email display range text including time
    function fmtRangeText(){
      const { start, end } = computeWindow();
      const mons = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const two = n => String(n).padStart(2,'0');
      const sTxt = `${mons[start.getMonth()]} ${start.getDate()} ${start.getFullYear()} ${two(start.getHours())}:${two(start.getMinutes())}`;
      const eTxt = `${mons[end.getMonth()]} ${end.getDate()} ${end.getFullYear()} ${two(end.getHours())}:${two(end.getMinutes())}`;
      return `Date Range: ${sTxt} to ${eTxt}`;
    }

    // Email-friendly table (with borders, center numeric, fill zeros for pivot/Total)
    function buildEmailTable(columns, rows, opts){
      const pivotCols = (columns||[]).filter(c => /\d{2}-[A-Za-z]{3}-\d{2}|^Total$/i.test(String(c||'')));
      const thead = '<thead><tr>' + (columns||[]).map(c => 
        `<th style="font-weight:700;text-align:left;padding:6px 8px;border:1px solid #ddd;background-color:#f8f9fa;">${escapeHtml(c)}</th>`
      ).join('') + '</tr></thead>';
      const tbody = '<tbody>' + (rows||[]).map((r, idx) => {
        const style = (opts && opts.highlightFirst && idx < opts.highlightFirst) ? ' style="color:#d93025;font-weight:700;"' : '';
        const tds = r.map((v, i) => {
          const col = columns[i];
          let val = v;
          const isPivot = pivotCols.includes(col);
          // zero-fill for pivot/Total blanks
          if ((val === null || val === undefined || String(val).trim() === '') && isPivot){ val = '0'; }
          const cellStyle = isPivot ? 'text-align:center;padding:6px 8px;border:1px solid #ddd;' : 'padding:6px 8px;border:1px solid #ddd;';
          return `<td style="${cellStyle}">${escapeHtml(val===null||val===undefined?'':val)}</td>`;
        }).join('');
        return `<tr${style}>` + tds + '</tr>';
      }).join('') + '</tbody>';
      return `<table style="border-collapse:collapse;width:100%;background:#fff;border:1px solid #ddd;margin-bottom:20px;">` + thead + tbody + '</table>';
    }

    // Email-friendly table (no borders, center numeric, fill zeros for pivot/Total)
    function buildTable(columns, rows, opts){
      const pivotCols = (columns||[]).filter(c => /\d{2}-[A-Za-z]{3}-\d{2}|^Total$/i.test(String(c||'')));
      const thead = '<thead><tr>' + (columns||[]).map(c => `<th>${escapeHtml(c)}</th>`).join('') + '</tr></thead>';
      const tbody = '<tbody>' + (rows||[]).map((r, idx) => {
        const style = (opts && opts.highlightFirst && idx < opts.highlightFirst) ? ' style="color:#d93025;font-weight:700;"' : '';
        const tds = r.map((v, i) => {
          const col = columns[i];
          let val = v;
          const isPivot = pivotCols.includes(col);
          if ((val === null || val === undefined || String(val).trim() === '') && isPivot){ val = '0'; }
          const cls = isPivot ? ' class="num"' : '';
          return `<td${cls}>${escapeHtml(val===null||val===undefined?'':val)}</td>`;
        }).join('');
        return `<tr${style}>` + tds + '</tr>';
      }).join('') + '</tbody>';
      return '<table>' + thead + tbody + '</table>';
    }
    

    // Helper: case-insensitive column index
    function colIdx(cols, name){
      if (!cols) return -1;
      const target = String(name).toLowerCase();
      for (let i = 0; i < cols.length; i++){
        if (String(cols[i]||'').toLowerCase() === target) return i;
      }
      return -1;
    }

    // CSV parsing (simple) and spec helpers
    function parseCsvToObjects(text){
      const lines = String(text||'').split(/\r?\n/).filter(l => l.trim().length);
      if (!lines.length) return [];
      const header = lines.shift().split(',').map(h => h.trim());
      return lines.map(line => {
        const vals = line.split(',');
        const obj = {};
        for (let i = 0; i < header.length; i++) obj[header[i]] = vals[i] || '';
        return obj;
      });
    }
    function normalize(s){ return String(s||'').trim().toLowerCase(); }
    function readSpecField(row, logical){
      const target = String(logical||'').trim().toLowerCase().replace(/[^a-z0-9]/g,'');
      const keys = Object.keys(row||{});
      for (const k of keys){
        const keyNorm = String(k||'').trim().toLowerCase().replace(/[^a-z0-9]/g,'');
        if (keyNorm === target) return row[k];
      }
      return '';
    }
    async function fetchSpecCsv(){
      // Prefer test.csv in UI directory
      try {
        const r = await fetch('test.csv');
        if (r.ok){ const t = await r.text(); return parseCsvToObjects(t); }
      } catch {}
      // Fallback to served UI path
      try {
        const r2 = await fetch('http://127.0.0.1:8765/mcp-client/ui/test.csv');
        if (r2.ok){ const t2 = await r2.text(); return parseCsvToObjects(t2); }
      } catch {}
      // Last resort: legacy order_status_mapping.csv if test.csv is absent
      try {
        const r3 = await fetch('order_status_mapping.csv');
        if (r3.ok){ const t3 = await r3.text(); return parseCsvToObjects(t3); }
      } catch {}
      try {
        const r4 = await fetch('http://127.0.0.1:8765/mcp-client/ui/order_status_mapping.csv');
        if (r4.ok){ const t4 = await r4.text(); return parseCsvToObjects(t4); }
      } catch {}
      return [];
    }

    // Order history fetch for validation
    async function fetchOrderHistory(cartid, ordernumber, locationcode, mtn){
      const params = {}; const selects = [];
      const base = `SELECT * FROM POJO_data.vzcm_data_orderhistory sub WHERE`;
      const isEmpty = (v) => !v || !String(v).trim() || String(v).trim().toUpperCase() === 'N/A';
      if (!isEmpty(cartid)) { params.cartid = String(cartid).trim(); selects.push(`${base} sub.cartid = :cartid`); }
      if (!isEmpty(ordernumber) && !isEmpty(locationcode)) { params.ordernumber = String(ordernumber).trim(); params.locationcode = String(locationcode).trim(); selects.push(`${base} (sub.ordernumber = :ordernumber AND sub.locationcode = :locationcode)`); }
      if (!isEmpty(mtn)) { params.mtn = String(mtn).trim(); selects.push(`${base} sub.mtn = :mtn`); }
      if (!selects.length) return { columns: [], rows: [] };
      const sql = `${selects.join(' UNION ')}`;
      const resp = await fetch(ORACLE_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sql, params, maxRows: 5000 }) });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data.error || 'History query failed');
      return data;
    }

    function validateHistoryAgainstSpec(historyData, specRows, ids){
      const cols = (historyData.columns || []).map(c => String(c||''));
      const up = cols.map(c => c.toUpperCase());
      const idxStep = up.indexOf('ENTITYSTEP');
      const idxStatus = up.indexOf('WORKOBJECTSTATUS');
      const outCols = ['RESULT','REASON','EXPECTED_ENTITYSTEP','EXPECTED_WORKOBJECTSTATUS','ENTITYSTEP','WORKOBJECTSTATUS'];
      const spec = (specRows||[]).map(r => {
        const stepRaw = String(readSpecField(r, 'EntityStep')||'').trim();
        const statusRaw = String(readSpecField(r, 'WorkObjectStatus')||'').trim();
        return { stepNorm: normalize(stepRaw), stepRaw, statusNorm: normalize(statusRaw), statusRaw };
      }).filter(x => x.stepNorm);
      const outRows = [];
      for (const row of (historyData.rows||[])){
        const hStep = String(row[idxStep]||'').trim();
        const hStatusRaw = String(row[idxStatus]||'').trim();
        const hStatusNorm = normalize(hStatusRaw);
        const hStepNorm = normalize(hStep);
        const matches = spec.filter(s => s.stepNorm === hStepNorm);
        if (!matches.length){
          outRows.push(['FAIL','No matching EntityStep in sheet','','', hStep, hStatusRaw]);
        } else {
          const ok = matches.some(s => hStatusNorm === s.statusNorm || (hStatusRaw === '' && s.statusRaw === ''));
          const m = matches[0];
          outRows.push([ok?'PASS':'FAIL', ok?'success':'WorkObjectStatus is mismatched', m.stepRaw, m.statusRaw, hStep, hStatusRaw]);
        }
      }
      return { columns: outCols, rows: outRows, ids };
    }

    // Compute max daily count in a pivot row
    function maxDailyCount(columns, row){
      const pivotCols = (columns||[]).filter(c => /\d{2}-[A-Za-z]{3}-\d{2}/i.test(String(c||'')));
      let max = 0;
      for (let i = 0; i < (columns||[]).length; i++){
        const col = columns[i];
        if (pivotCols.includes(col)){
          const v = Number(row[i]||0);
          if (!isNaN(v)) max = Math.max(max, v);
        }
      }
      return max;
    }

    // Read Total column value from a pivot row
    function totalCount(columns, row){
      const idx = colIdx(columns || [], 'Total');
      const v = idx >= 0 ? Number(row[idx] || 0) : 0;
      return isNaN(v) ? 0 : v;
    }

    // Build detail SQL per hierarchy for a specific WorkObjectStatus within selected window
    function makeDetailSql(hierarchy, status){
      const { start, end } = computeWindow();
      const s_ts = `${start.getFullYear()}-${String(start.getMonth()+1).padStart(2,'0')}-${String(start.getDate()).padStart(2,'0')}T${String(start.getHours()).padStart(2,'0')}:${String(start.getMinutes()).padStart(2,'0')}`;
      const e_ts = `${end.getFullYear()}-${String(end.getMonth()+1).padStart(2,'0')}-${String(end.getDate()).padStart(2,'0')}T${String(end.getHours()).padStart(2,'0')}:${String(end.getMinutes()).padStart(2,'0')}`;
      if (hierarchy === 'line'){
        return `SELECT 
    line.PYSTATUSWORK, 
    line.WORKOBJECTSTATUS,
    line.CARTID, line.ORDERNUMBER, line.LOCATIONCODE,
    ful.FULFILLMENTTYPE, 
    ful.TRANSACTIONTYPE,
    line.INVENTORYAVAILABLE_OR, line.CHARGESTATUS_OR, line.CLOSELOAN_OR, 
    line.CREATELOAN_OR, line.CANCELLOAN_OR, line.RDB_OR, line.GOAI_OR, 
    line.VOT_OR, line.PERSPAIR_OR, line.EXTENDRESERVATION_OR, 
    line.APPLEPARKORDER_OR, line.APPLECARE_OR, line.EQUIPMENTWARRANTYENTRY_OR, 
    line.SHIPPINGRECEIPT_OR, line.SHIPMENTCONFIRMATIONEMAIL_OR, 
    line.ACTIVATIONSTATUS_OR, line.CANCELORDER_OR, line.VOIDSAPITEMS_OR, 
    line.CANCELEMAIL_OR, line.VOIDPAYMENT_OR, line.SIMOTAPROGRAMMING 
FROM POJO_data.vzcm_data_lineentity line
INNER JOIN POJO_data.vzcm_data_fulfillmententity ful 
    ON line.CARTID = ful.CARTID
WHERE line.WORKOBJECTSTATUS = '${status.replace(/'/g, "''")}'
  AND line.PXCREATEDATETIME BETWEEN TO_TIMESTAMP('${s_ts}', 'YYYY-MM-DD"T"HH24:MI') AND TO_TIMESTAMP('${e_ts}', 'YYYY-MM-DD"T"HH24:MI')
  AND line.LINEACTIVITYTYPE = 'AAL' 
  AND line.CLIENTTYPE = 'Digital'
  AND ful.FULFILLMENTTYPE = 'FFL'
ORDER BY line.PXCREATEDATETIME DESC
FETCH FIRST 3 ROWS ONLY`;
      } else if (hierarchy === 'order'){
        return `SELECT 
    conf.PYSTATUSWORK, 
    conf.WORKOBJECTSTATUS,
    conf.CARTID, conf.ORDERNUMBER, conf.LOCATIONCODE,
    ful.FULFILLMENTTYPE, 
    ful.TRANSACTIONTYPE,
    conf.FRAUDVERIFICATIONSTATUS,
    conf.MODIFYCREDIT_OR, conf.SAVEOFFER_OR, conf.COMMITOFFER_OR, 
    conf.SECUREPAY_OR, conf.FRAUDSUBMISSIONTIMESTAMP_OR, conf.CHARGESTATUS_OR, 
    conf.TRADEACCOUNTCHARGE_OR, conf.TRADEGIFTCARD_OR, conf.TRADECREDITSTATUS_OR, 
    conf.CANCELORDER_OR, conf.VOIDSAPITEMS_OR, conf.VOIDPAYMENT_OR, conf.CANCELEMAIL_OR, 
    conf.SUBMITPAYMENT_OR, conf.SUBMITBAPAYMENT_OR, conf.MDMANAGERAPPROVAL_OR, conf.CTOC_OR,
    conf.FRAUDRELEASETIMESTAMP, conf.CREATEINVENTORYBLOCK, conf.SKIPSUBMITPAYMENT, conf.SAVELOAN, conf.GENERATERECEIPT
FROM POJO_data.vzcm_data_orderconfirmationentity conf
LEFT JOIN POJO_data.vzcm_data_fulfillmententity ful 
    ON conf.CARTID = ful.CARTID
WHERE conf.WORKOBJECTSTATUS = '${status.replace(/'/g, "''")}'
  AND conf.PXCREATEDATETIME BETWEEN TO_TIMESTAMP('${s_ts}', 'YYYY-MM-DD"T"HH24:MI') AND TO_TIMESTAMP('${e_ts}', 'YYYY-MM-DD"T"HH24:MI')
  AND conf.ORDERACTIVITYTYPE = 'AAL' 
  AND conf.CLIENTTYPE = 'Digital'
  AND (ful.FULFILLMENTTYPE = 'FFL' OR ful.FULFILLMENTTYPE IS NULL)
ORDER BY conf.PXCREATEDATETIME DESC
FETCH FIRST 3 ROWS ONLY`;
      } else { // cart
        return `SELECT 
    sub.PYSTATUSWORK, 
    sub.WORKOBJECTSTATUS,
    sub.CARTID,
    ful.FULFILLMENTTYPE, 
    ful.TRANSACTIONTYPE,
    sub.BIOCATCH_OR, sub.ASSIGNMTN_OR, sub.GENERATEINSTALLMENTSCONTRACTS_OR, 
    sub.PROMOJOURNEYINITATION_OR, sub.REVERSEJOURNEYINITATION_OR, sub.CARTSTATUS_OR, 
    sub.ISSEDOFFER, sub.PREORDERWRITE_OR, sub.FULLAUTHREQUIRED, sub.ASSIGNMTNREQUIRED
FROM POJO_data.vzcm_data_ordersubmitentity sub
INNER JOIN POJO_data.vzcm_data_fulfillmententity ful 
    ON sub.CARTID = ful.CARTID
WHERE sub.WORKOBJECTSTATUS = '${status.replace(/'/g, "''")}'
  AND sub.PXCREATEDATETIME BETWEEN TO_TIMESTAMP('${s_ts}', 'YYYY-MM-DD"T"HH24:MI') AND TO_TIMESTAMP('${e_ts}', 'YYYY-MM-DD"T"HH24:MI')
  AND sub.CLIENTTYPE = 'Digital'
  AND ful.FULFILLMENTTYPE = 'FFL'
ORDER BY sub.PXCREATEDATETIME DESC
FETCH FIRST 3 ROWS ONLY`;
      }
    }

    // Format recent carts list from detail dataset
    function formatRecent(detail){
      if (!detail || !detail.columns || !detail.rows) return 'N/A';
      const cols = detail.columns; const rows = detail.rows;
      const iCart = colIdx(cols, 'CARTID');
      const iOrder = colIdx(cols, 'ORDERNUMBER');
      const iLoc = colIdx(cols, 'LOCATIONCODE');
      const items = rows.map(r => {
        let s = '';
        if (iCart >= 0) s = String(r[iCart]||'');
        if (iOrder >= 0) s += s ? `/${String(r[iOrder]||'')}` : String(r[iOrder]||'');
        if (iLoc >= 0) s += s ? `/${String(r[iLoc]||'')}` : String(r[iLoc]||'');
        return s;
      });
      const joined = items.slice(0,3).map(escapeHtml).join(', ');
      return joined.trim() ? joined : 'N/A';
    }

    // Append a "Recent Carts (Top 3)" column to an existing dataset using a details map keyed by status
    function appendRecentColumn(dataset, detailsMap){
      const columns = dataset.columns || [];
      const rows = dataset.rows || [];
      const idxStatus = colIdx(columns, 'WORKOBJECTSTATUS');
      const newCols = columns.concat(['Recent Carts (Top 3)']);
      const newRows = rows.map((r, i) => {
        let extra = '';
        if (i < 5 && idxStatus >= 0){
          const status = String(r[idxStatus]||'');
          const det = detailsMap && detailsMap[status];
          extra = formatRecent(det);
        }
        return r.concat([extra]);
      });
      return { columns: newCols, rows: newRows };
    }

    async function runHealthcheck(){
      const statusEl = document.getElementById('status');
      const resultsEl = document.getElementById('results');
      const previewLink = document.getElementById('previewLink');
      // Clear results and show spinner immediately on click
      resultsEl.innerHTML = '';
      statusEl.innerHTML = 'Loading recent carts and sending email... <span class="spinner"></span>';
      previewLink.style.display = 'none';
      try {
        // Build SQLs for each hierarchy (Cart -> Order -> Line)
        const SQL_SUBMIT = makeSql('POJO_data.vzcm_data_ordersubmitentity');
        const SQL_CONFIRM = makeSql('POJO_data.vzcm_data_orderconfirmationentity');
        const SQL_LINE = makeSql('POJO_data.vzcm_data_lineentity');
        const pCart = fetch(ORACLE_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sql: SQL_SUBMIT, params: {}, maxRows: 5000 }) });
        const pOrder = fetch(ORACLE_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sql: SQL_CONFIRM, params: {}, maxRows: 5000 }) });
        const pLine = fetch(ORACLE_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sql: SQL_LINE, params: {}, maxRows: 5000 }) });
        const [rCart, rOrder, rLine] = await Promise.all([pCart, pOrder, pLine]);
        const [dCart, dOrder, dLine] = await Promise.all([rCart.json(), rOrder.json(), rLine.json()]);
        if (!rCart.ok) throw new Error(dCart.error || 'Cart query failed');
        if (!rOrder.ok) throw new Error(dOrder.error || 'Order query failed');
        if (!rLine.ok) throw new Error(dLine.error || 'Line query failed');
        // Render pivot results first
        const hCart0 = `<h3 style="margin:12px 0 6px 0;">Hierarchy: Cart</h3>` + buildTable(dCart.columns || [], dCart.rows || [], { highlightFirst: 5 });
        const hOrder0 = `<h3 style="margin:12px 0 6px 0;">Hierarchy: Order</h3>` + buildTable(dOrder.columns || [], dOrder.rows || [], { highlightFirst: 5 });
        const hLine0 = `<h3 style=\"margin:12px 0 6px 0;\">Hierarchy: Line</h3>` + buildTable(dLine.columns || [], dLine.rows || [], { highlightFirst: 5 });
        const pageHtml0 = hCart0 + hOrder0 + hLine0;
        const rangeInfoEl = document.getElementById('rangeInfo');
        if (rangeInfoEl) { rangeInfoEl.innerHTML = fmtRangeText(); }
        resultsEl.innerHTML = pageHtml0;
        // Now trigger details (keep spinner message)
        // Determine top-5 WorkObjectStatus per hierarchy
        const iCartStatus = colIdx(dCart.columns || [], 'WORKOBJECTSTATUS');
        const iOrderStatus = colIdx(dOrder.columns || [], 'WORKOBJECTSTATUS');
        const iLineStatus = colIdx(dLine.columns || [], 'WORKOBJECTSTATUS');
        // Only trigger details when Total > 20000
        const topCartStatuses = (dCart.rows || [])
          .slice(0,5)
          .filter(r => totalCount(dCart.columns || [], r) > 20000)
          .map(r => iCartStatus>=0 ? String(r[iCartStatus]||'') : '')
          .filter(s => s);
        const topOrderStatuses = (dOrder.rows || [])
          .slice(0,5)
          .filter(r => totalCount(dOrder.columns || [], r) > 20000)
          .map(r => iOrderStatus>=0 ? String(r[iOrderStatus]||'') : '')
          .filter(s => s);
        const topLineStatuses = (dLine.rows || [])
          .slice(0,5)
          .filter(r => totalCount(dLine.columns || [], r) > 20000)
          .map(r => iLineStatus>=0 ? String(r[iLineStatus]||'') : '')
          .filter(s => s);

        // Fetch recent carts per status (3 rows)
        const fetchDetail = async (hier, statuses) => {
          // Sequential fetching to avoid network/DB connection resets
          const m = {};
          for (const st of statuses){
            try {
              const resp = await fetch(ORACLE_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sql: makeDetailSql(hier, st), params: {}, maxRows: 25 }) });
              const d = await resp.json();
              if (resp.ok) m[st] = d;
            } catch {
              // ignore
            }
            // small delay to avoid rapid-fire connections
            await new Promise(r => setTimeout(r, 75));
          }
          return m;
        };
        const [cartDet, orderDet, lineDet] = await Promise.all([
          fetchDetail('cart', topCartStatuses),
          fetchDetail('order', topOrderStatuses),
          fetchDetail('line', topLineStatuses)
        ]);

        // Load spec CSV for validation
        const specRows = await fetchSpecCsv();

        // Build per-status recent most cart with validation, honoring thresholds
        async function buildValidatedMap(hier, dataset, detMap){
          const out = {};
          const cols = dataset.columns||[]; const idxStatus = colIdx(cols, 'WORKOBJECTSTATUS');
          for (let rIdx = 0; rIdx < Math.min(5, (dataset.rows||[]).length); rIdx++){
            const row = dataset.rows[rIdx];
            const status = idxStatus>=0 ? String(row[idxStatus]||'') : '';
            if (!status) continue;
            const t = totalCount(cols, row);
            if (!(t > 20000)) continue; // trigger only if Total > 20000
            // Fetch most recent cart row
            const det = detMap[status];
            const dcols = det && det.columns || []; const drows = det && det.rows || [];
            const iCart = colIdx(dcols, 'CARTID');
            const iOrd = colIdx(dcols, 'ORDERNUMBER');
            const iLoc = colIdx(dcols, 'LOCATIONCODE');
            let cartid = (iCart>=0 && drows[0]) ? drows[0][iCart] : '';
            let ordernumber = (iOrd>=0 && drows[0]) ? drows[0][iOrd] : '';
            let locationcode = (iLoc>=0 && drows[0]) ? drows[0][iLoc] : '';
            let mtn = '';
            // Fill missing fields for CART/ORDER
            if (hier === 'cart'){
              // Get ORDERNUMBER/LOCATIONCODE
              try {
                const sql = `SELECT ORDERNUMBER, LOCATIONCODE FROM POJO_data.vzcm_data_orderconfirmationentity WHERE CARTID = :cartid AND CLIENTTYPE = 'Digital' ORDER BY PXCREATEDATETIME DESC FETCH FIRST 1 ROWS ONLY`;
                const resp = await fetch(ORACLE_ENDPOINT, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ sql, params: { cartid }, maxRows: 5 }) });
                const data = await resp.json();
                if (resp.ok){
                  const cOn = colIdx(data.columns||[], 'ORDERNUMBER');
                  const cLc = colIdx(data.columns||[], 'LOCATIONCODE');
                  if ((data.rows||[])[0]){
                    ordernumber = (data.rows[0][cOn]||ordernumber);
                    locationcode = (data.rows[0][cLc]||locationcode);
                  }
                }
              } catch {}
            }
            if (hier === 'order' || hier === 'cart'){
              // Get MTN from lineentity for CARTID
              try {
                const sql2 = `SELECT MTN FROM POJO_data.vzcm_data_lineentity WHERE CARTID = :cartid AND CLIENTTYPE = 'Digital' AND LINEACTIVITYTYPE = 'AAL' ORDER BY PXCREATEDATETIME DESC FETCH FIRST 1 ROWS ONLY`;
                const resp2 = await fetch(ORACLE_ENDPOINT, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ sql: sql2, params: { cartid }, maxRows: 5 }) });
                const data2 = await resp2.json();
                if (resp2.ok){
                  const iM = colIdx(data2.columns||[], 'MTN') >= 0 ? colIdx(data2.columns||[], 'MTN') : (colIdx(data2.columns||[], 'ORDER_MTN')>=0 ? colIdx(data2.columns||[], 'ORDER_MTN') : colIdx(data2.columns||[], 'LINE_MTN'));
                  mtn = (data2.rows||[])[0] ? data2.rows[0][iM] : '';
                }
              } catch {}
            } else if (hier === 'line'){
              // For line, MTN may already be part of history, but keep as '' here; validation uses orderhistory fields.
            }
            // Validate against spec
            try {
              const hist = await fetchOrderHistory(cartid, ordernumber, locationcode, mtn);
              const v = validateHistoryAgainstSpec(hist, specRows, { cartid, ordernumber, locationcode, mtn });
              const pass = (v.rows||[]).every(r => r[0] === 'PASS');
              out[status] = { cartid, ordernumber, locationcode, mtn, result: pass ? 'PASS' : 'FAIL' };
            } catch {
              out[status] = { cartid, ordernumber, locationcode, mtn, result: '' };
            }
          }
          return out;
        }
        const [cartVal, orderVal, lineVal] = await Promise.all([
          buildValidatedMap('cart', dCart, cartDet),
          buildValidatedMap('order', dOrder, orderDet),
          buildValidatedMap('line', dLine, lineDet)
        ]);

        // Append recent most cart with validation result column
        function appendValidatedColumn(dataset, valMap){
          const columns = dataset.columns||[]; const rows = dataset.rows||[];
          const idxStatus = colIdx(columns, 'WORKOBJECTSTATUS');
          const newCols = columns.concat(['Recent Cart (Most)']);
          const newRows = rows.map((r, i) => {
            let extra = 'N/A';
            if (i < 5 && idxStatus>=0){
              const st = String(r[idxStatus]||'');
              const info = valMap[st];
              if (info && info.cartid){
                const badge = info.result ? ` [${info.result}]` : '';
                extra = `${escapeHtml(info.cartid)}${badge}`;
              }
            }
            return r.concat([extra]);
          });
          return { columns: newCols, rows: newRows };
        }

        const cartAug = appendValidatedColumn(dCart, cartVal);
        const orderAug = appendValidatedColumn(dOrder, orderVal);
        const lineAug = appendValidatedColumn(dLine, lineVal);

        const hCart = `<h3 style="margin:12px 0 6px 0;">Hierarchy: Cart</h3>` + buildTable(cartAug.columns, cartAug.rows, { highlightFirst: 5 });
        const hOrder = `<h3 style="margin:12px 0 6px 0;">Hierarchy: Order</h3>` + buildTable(orderAug.columns, orderAug.rows, { highlightFirst: 5 });
        const hLine = `<h3 style="margin:12px 0 6px 0;">Hierarchy: Line</h3>` + buildTable(lineAug.columns, lineAug.rows, { highlightFirst: 5 });
        const pageHtml = hCart + hOrder + hLine;
        // Show browser date-time range below controls
        if (rangeInfoEl) { rangeInfoEl.innerHTML = fmtRangeText(); }
        resultsEl.innerHTML = pageHtml;
        // Compose email HTML (no global header; only hierarchy headers)
        const subject = fmtSubjectRange();
        const emailRange = `<div style="color:#1a73e8;font-weight:700;font-size:14px;margin:4px 0;">${fmtRangeText()}</div>`;
        const eCart = `<h3 style="margin:12px 0 6px 0;">Hierarchy: Cart</h3>` + buildEmailTable(cartAug.columns, cartAug.rows, { highlightFirst: 5 });
        const eOrder = `<h3 style="margin:12px 0 6px 0;">Hierarchy: Order</h3>` + buildEmailTable(orderAug.columns, orderAug.rows, { highlightFirst: 5 });
        const eLine = `<h3 style="margin:12px 0 6px 0;">Hierarchy: Line</h3>` + buildEmailTable(lineAug.columns, lineAug.rows, { highlightFirst: 5 });
        const bodyHtml = `<div style="font-family:Segoe UI,Arial,sans-serif;font-size:13px;">${emailRange}${eCart}${eOrder}${eLine}</div>`;
        const mailResp = await fetch(MAIL_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ to: 'marieswari.palanimarimuthu@verizon.com', subject, html: bodyHtml }) });
        let mailData = {};
        try { mailData = await mailResp.json(); } catch {}
        if (mailResp.ok && (mailData.ok || mailData.sent)){
          statusEl.innerHTML = '<span class="success">Email sent successfully.</span>';
        } else {
          const msg = mailData.error ? String(mailData.error) : `HTTP ${mailResp.status}`;
          statusEl.innerHTML = `<span class="error">Email send failed: ${escapeHtml(msg)}</span>`;
          if (mailData.previewPath){ previewLink.href = `http://127.0.0.1:8765${mailData.previewUrl || '/preview/healthcheck-email'}`; previewLink.textContent = 'Open email preview'; previewLink.style.display = 'inline-block'; }
        }
      } catch (e){
        statusEl.innerHTML = `<span class="error">${escapeHtml(e.message)}</span>`;
      }
    }

    // Range buttons
    document.querySelectorAll('.ranges button').forEach(btn => {
      btn.addEventListener('click', () => {
        activeWindow = { type: 'relative', value: btn.getAttribute('data-range') };
        runHealthcheck();
      });
    });
    // Do not auto-run on initial load; user must click a range
  </script>
</body>
</html>
